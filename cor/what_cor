typedef struct			s_proc {
	unsigned int		pid;
	unsigned int		pos;
	bool				carry;
	int					player_nbr;
	unsigned char		cmnd;
	bool				live;
	unsigned int		reg[16];
	unsigned int		cycles_to_do;
	struct s_proc		*next;
}						t_proc;

typedef struct			s_champ {
	char				name[PROG_NAME_LENGTH + 1];
	unsigned int		execsize;
	char				comm[COMMENT_LENGTH + 1];
	union chmp_exec		exec;
}						t_champ;

typedef struct			s_prog {
	unsigned int		verbose;
	unsigned int		nbr_cycles;
	int					player_nbr[MAX_PLAYERS];
	t_champ				champs[MAX_PLAYERS];
	unsigned int		(*funcs[16])(*t_procs, *t_prog, *t_arg_type, *unsigned char);
	int					lives[MAX_PLAYERS];
	int					players;
	int					checks_nbr;
	short				last_live_nbr;
}						t_prog;












1. Всего есть 16 функций, как их лучше вызывать, чтобы передавать вседанные, которые они содержат.
2. Как лучше работать с кодадж?
3. 



ПК («Счетчик программ»). Это специальный реестр, который содержит только в памяти виртуальной машины адрес следующего набора инструкций для кодирования и выполнения. Очень полезно выяснить, где мы находимся в процессе выполнения, давая советы о том, когда писать материал в памяти ...


 REG_NUMBER registries, each of which are the size REG_SIZE octets. A registry is a small memory “box” with only one value. On a real machine, it is an internal of the processor and as a result very FAST to access.
◦ A PC ("Program Counter"). This is a special registry that only contains, within the memory of the virtual machine, the address of the next set of instructions to code and execute. Very useful to figure out where we are at in the execution, giving us tips on when to write stuff in the memory...
◦ A flag named carry, if the latest operation was successful. Only certain op- erations can modify the carry.



The number of the player is generated by the machine or specified at launch and is given to the champions via the r1 registry of their first process at startup. All the other registries are at 0, except PC.

Номер игрока генерируется машиной или указывается при запуске и присваивается чемпионам через реестр r1 их первого процесса при запуске. Все остальные регистры равны 0, кроме ПК.



The champions are charged within the memory so that they can space out evenly their entry points.
• The virtual machine will create a memory space dedicated to the combat of the players, it will then load each champion and their associated processes and execute them sequentially until they die.
• Every CYCLE_TO_DIE cycles, the machine needs to make sure that each process has executed at least one live since the last check. A process that does not abide by this rule will be killed immediately with a virtual foamy bat (bonus for sound effect!)
• If during one of those checkup we notice that there has been at least one NBR_LIVE execution of live since the latest check up, we will decrease CYCLE_TO_DIE of CYCLE_DELTA units.
• The game is over when all processes are dead.

Чемпионы заряжаются в памяти, чтобы они могли равномерно распределять точки входа.
• Виртуальная машина создаст пространство памяти, предназначенное для борьбы с игроками, затем загрузит каждого чемпиона и связанные с ним процессы и выполнит их последовательно до тех пор, пока они не умрут.
!!!!!!
• Каждый цикл CYCLE_TO_DIE, машина должна убедиться, что каждый процесс выполнил хотя бы одну запись с момента последней проверки. Процесс, который не соблюдает это правило, немедленно будет уничтожен виртуальной пенной летучей мышью (бонус за звуковой эффект!)

• Если во время одного из проверок мы заметили, что с момента последней проверки было выполнено хотя бы одно NBR_LIVE?????, мы уменьшим CYCLE_TO_DIE единиц CYCLE_DELTA.
• Игра заканчивается, когда все процессы мертвы.



The winner is the last player to be reported alive. The machine will then show “Player X (champion_name) won”, where X is the player’s number and cham- pion_name is its name.
For example: “Player 2 (rainbowdash) won”.
• For each valid execution of the live instruction, the machine must display: “A process shows that player X (champion_name) is alive”.
• In any case, memory is circular and of MEM_SIZE octets.
• In case of an error, you must display a relevant error message on the standard error
output.
• If CYCLE_TO_DIE wasn’t decreased since MAX_CHECKS checkups, decrease it.


Победителем является последний игрок, которого нужно сообщить живым. Затем машина покажет «Player X (champion_name) won», где X - номер игрока, а имя champion_name - его имя.
Например: «Игрок 2 (радуга) выиграл».
• Для каждого действительного выполнения живой команды машина должна отображать: «Процесс показывает, что игрок X (имя чемпионов) жив».
• В любом случае память является круговой и октетами MEM_SIZE.
• В случае ошибки вы должны отобразить соответствующее сообщение об ошибке при стандартной ошибке
вывод.
• Если CYCLE_TO_DIE не уменьшилось после проверки MAX_CHECKS, уменьшите его.


The virtual machine should be executed like that:
> ./corewar [-dump nbr_cycles] [[-n number] champion1.cor] ...


• -dump nbr_cycles
at the end of nbr_cycles of executions, dump the memory on the standard output and quit the game. The memory must be dumped in the hexadecimal format with 32 octets per line.
• -n number
sets the number of the next player. If non-existent, the player will have the next available number in the order of the parameters. The last player will have the first process in the order of execution.
• The champions cannot go over CHAMP_MAX_SIZE, otherwise it is an error.
> ./corewar [-dump nbr_cycles] [[-n number] champion1.cor] ...

в конце nbr_cycles исполнений выгрузите память на стандартный вывод и выйдите из игры. Память должна быть сброшена в шестнадцатеричном формате с 32 октетами в строке.
• -n число
задает номер следующего игрока. Если не существует, у игрока будет следующий доступный номер в порядке параметров. У последнего игрока будет первый процесс в порядке выполнения.
• Чемпионы не могут пройти CHAMP_MAX_SIZE, в противном случае это ошибка.
> ./corewar [-dump nbr_cycles] [[-n number] champion1.cor] ...








VM structure

1. Memory map creator +
2. Input args validator +
3. Binary validator (check size < 628) +
4. Binary reader (прочитать все разделы и записать в структуру чемпиона) +
5. Champ ops + process ops (создание, удаление структур champ/PC)
6. Main machine (крутит циклы и проверяет живы ли процессы + уменьшает cycles_to_die)^ на каждом цикле процессы прогоняются с самого высокого id
7. Process controller (двигает каретку и выбирает нужную команду)
8. Command implementers (исполнители комманд)
9. Command auxiliary (вспомогательные функции для команд)
10. Responder (Каждое действие логгируется verbose mode)
11. Result printer (можно сделать частью респондера)
12. Memory dumper +


https://docs.google.com/drawings/d/1jweFlG9AaF1fBB9seybEzBscRPRgUUkgvZBrkL7Nylw/edit











Разбивка целей проекта
Этот проект можно разделить на три отличительные части:
• Ассемблер: это программа, которая скомпилирует ваших чемпионов и передаст их с языка, на котором вы будете записывать их (язык ассемблера) в «Байт-код». Bytecode - это машинный код, который будет непосредственно интерпретировать виртуальная машина.
• Виртуальная машина: это «арена», в которой ваши чемпионы будут исполнены. Он предлагает различные функции, которые будут полезны для битвы чемпионов. Очевидно, что виртуальная машина должна допускать многочисленные одновременные процессы; мы просим вас о поединке с гладиатором, а не о симуляторе шоу с одним человеком.
• Чемпион: Это особый случай. Позже, в чемпионате, вам нужно будет стать супермощным чемпионом, который напугает команду сотрудников до смерти. Тем не менее, предоставление такого рода чемпионов - серьезная работа. И так как на данный момент нас больше всего интересует ваша способность создавать другие программы Corewar (т. Е. Ассемблер и виртуальную машину), ваш нынешний чемпион должен будет доказать нам, что вы можете писать бит и куски Corewar ASM. Это означает, что для того, что вы должны сделать для этого проекта, нужно только напугать бежеус из неврастенического ежа.
Также будет чемпионат Corewar, для которого вы создадите новых чемпионов, которые будут сражаться в серии эпических битв. Высочайшая точка этого чемпионата заставит Game of Thrones выглядеть вздремнуть в детском саду.
Обратите внимание, что чемпионат - это отдельный проект, для которого вы станете новым чемпионом. Поэтому было бы разумно сохранить ваши самые скрученные стратегии для себя, чтобы вы не стали, так сказать, смехом этого чемпионата крайней серьезности.



Каждый процесс будет иметь следующие доступные эксклюзивные элементы:
◦ REG_NUMBER реестры, каждый из которых представляет собой октеты REG_SIZE размера. Реестр представляет собой небольшую ячейку памяти с одним значением. На реальной машине это внутренняя часть процессора и, как результат, очень FAST для доступа.
◦ ПК («Счетчик программ»). Это специальный реестр, который содержит только в памяти виртуальной машины адрес следующего набора инструкций для кодирования и выполнения. Очень полезно выяснить, где мы находимся в процессе выполнения, давая советы о том, когда писать материал в памяти ...
◦ Флаг с именем нести, если последняя операция прошла успешно. Только некоторые операции могут изменить перенос.
• Номер игрока генерируется машиной или указывается при запуске и присваивается чемпионам через реестр r1 их первого процесса при запуске. Все остальные регистры равны 0, кроме ПК.
• Чемпионы заряжаются в памяти, чтобы они могли равномерно распределять точки входа.

• Виртуальная машина создаст пространство памяти, предназначенное для борьбы с игроками, затем загрузит каждого чемпиона и связанные с ним процессы и выполнит их последовательно до тех пор, пока они не умрут.
• Каждый цикл CYCLE_TO_DIE, машина должна убедиться, что каждый процесс выполнил хотя бы одну запись с момента последней проверки. Процесс, который не соблюдает это правило, немедленно будет уничтожен виртуальной пенной летучей мышью (бонус за звуковой эффект!)
• Если во время одного из проверок мы заметили, что с момента последней проверки было выполнено хотя бы одно NBR_LIVE, мы уменьшим CYCLE_TO_DIE единиц CYCLE_DELTA.
• Игра заканчивается, когда все процессы мертвы.

Победителем является последний игрок, которого нужно сообщить живым. Затем машина покажет «Player X (champion_name) won», где X - номер игрока, а имя champion_name - его имя.
Например: «Игрок 2 (радуга) выиграл».
• Для каждого действительного выполнения живой команды машина должна отображать: «Процесс показывает, что игрок X (имя чемпионов) жив».
• В любом случае память является круговой и октетами MEM_SIZE.
• В случае ошибки вы должны отобразить соответствующее сообщение об ошибке при стандартной ошибке
вывод.
• Если CYCLE_TO_DIE не уменьшилось после проверки MAX_CHECKS, уменьшите его.
• Виртуальная машина должна быть выполнена следующим образом:

> ./corewar [-dump nbr_cycles] [[-n number] champion1.cor] ...


-dump nbr_cycles
в конце nbr_cycles исполнений выгрузите память на стандартный вывод и выйдите из игры. Память должна быть сброшена в шестнадцатеричном формате с 32 октетами в строке.
• -n число
задает номер следующего игрока. Если не существует, у игрока будет следующий доступный номер в порядке параметров. У последнего игрока будет первый процесс в порядке выполнения.
• Чемпионы не могут пройти CHAMP_MAX_SIZE, в противном случае это ошибка.

