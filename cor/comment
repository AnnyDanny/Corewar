// ее нужно вызывать , когда истечек нужное количество циклов
// и нужно будет выполнять действие
// выполняется, когда не осталось живых процессов
// cycle_to_die <= 0

// должна проверять аргументы и обьявляьять живым процесс и чемпиона, если его имя в аргументе
// аргумнет T_DIR - это 4 байта
// у каждого чемпиона есть число-имя. Если в аргумента число какого-то из чемпионов, значит этот чемпион
// обьявляется живым, кто будет последний - тот выиграл
// процесс жив, пока его не убьет ВМ
// ВМ убивает те процессы, которые ни разу не выполнили инструкцию лив за количество циклов в cycle_to_die
// тот процесс, который приходит в лив - жив. нужно отметить это, чтобы ВМ его не убила. 
// вопросы:
// -где находятся процессы, которые должны прийти в аргументах лива, чтобы проверить, что они выполняют данную инструкцию?
// -инструкция лив должна вызываться каждый cycle_to_die


// T_REG - занимает только 1 байт
// T_IND - 2 байта
// T_DIR - столько байтов сколько указано в label_size у команды

// 1 байт - unsigned char
// 2 байта - short
// 4 байта - unsigned int
// codage - это первое число, размером в один байт - оно определяет тип следующего аргумента
// считать байт и проверить его
// считать аргумент и проверить его и сделать с ним что-то
// кодадж на карте - это положение процесса + 1 (для первого аргумента или все таки для всех аргументов?)
// в кодадже храниться значение, которое определяет сколько байтов весит следующий аргумент
// в кодадже может хваниться только 3 значение(вес аргумента), в соответствии с количеством трех аргументов
// #define IDX_MOD					(MEM_SIZE / 8)

// void	*ft_memcpy(void *dst, const void *src, size_t n)
// {
// 	size_t				i;
// 	unsigned char		*fdst;
// 	unsigned char		*fsrc;

// 	i = 0;
// 	fdst = (unsigned char *)dst;
// 	fsrc = (unsigned char *)src;
// 	while (i < n)
// 	{
// 		fdst[i] = fsrc[i];
// 		i++;
// 	}
// 	return (fdst);
// }

/*
если в аргументе хранится число:
- 1 = T_REG;
- 2 = T_DIR;
- 3 = T_IND;
*/

// ПК («Счетчик программ»). Это специальный реестр, который содержит 
// только в памяти виртуальной машины адрес следующего набора инструкций 
// для кодирования и выполнения. Очень полезно выяснить, где мы находимся 
// в процессе выполнения, давая советы о том, когда писать материал в памяти
// есть список всех процессов, который нужно обработать, этот каунтер помогает делать это по очереди


// Флаг с именем «carry», если последняя операция прошла успешно. Только некоторые операции могут изменить carry.